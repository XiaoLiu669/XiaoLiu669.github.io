<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB æ‰¹é‡å·¥å…· (æŒ‡å®šå¯¼å‡ºæ–‡ä»¶å¤¹)</title>
    <style>
        /* --- åŸºç¡€å¸ƒå±€ --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
        }

        .container {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 600px;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        /* --- ä¸Šä¼ åŒºåŸŸ --- */
        .upload-area {
            border: 2px dashed #ccc;
            padding: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.3s;
            background: #fafafa;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: #007bff;
            background: #eef7ff;
        }

        /* --- æŒ‰é’® --- */
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
            opacity: 0.6;
            transition: 0.3s;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #6c757d;
        }

        .btn:enabled {
            opacity: 1;
            background: #28a745;
        }

        .btn:enabled:hover {
            background: #218838;
        }

        /* --- å…¶ä»–UI --- */
        #status {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            white-space: pre-wrap;
        }

        .file-list {
            text-align: left;
            max-height: 120px;
            overflow-y: auto;
            background: #eee;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #555;
            display: none;
        }

        .options {
            text-align: left;
            margin-top: 10px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #eee;
        }

        .options label {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
            user-select: none;
        }

        input[type="checkbox"] {
            margin-right: 10px;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div class="container">
        <h1>ğŸ“‚ GLB æ‰¹é‡å·¥å…· (æŒ‡å®šå¯¼å‡ºä½ç½®)</h1>

        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>ğŸ“ ç‚¹å‡»æ­¤å¤„é€‰æ‹©å¤šä¸ªæ–‡ä»¶</p>
            <input type="file" id="fileInput" style="display: none;" multiple accept=".glb">
        </div>

        <div class="options">
            <label><input type="checkbox" id="fixY" checked><b>å‚ç›´ä¿®æ­£ (Fix Y):</b> æ¨¡å‹åº•éƒ¨å½’é›¶</label>
            <label><input type="checkbox" id="fixXZ" checked><b>æ°´å¹³ä¿®æ­£ (Fix X/Z):</b> æ¨¡å‹ä¸­å¿ƒå¯¹é½</label>
        </div>

        <div id="fileListDisplay" class="file-list"></div>
        <div id="status">ç­‰å¾…é€‰æ‹©æ–‡ä»¶...</div>

        <!-- æ³¨æ„æŒ‰é’®æ–‡å­—çš„å˜åŒ– -->
        <button id="processBtn" class="btn" disabled onclick="processAllFiles()">ğŸ’¾ é€‰æ‹©ä¿å­˜æ–‡ä»¶å¤¹å¹¶å¼€å§‹</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        const fileInput = document.getElementById('fileInput');
        const statusDiv = document.getElementById('status');
        const processBtn = document.getElementById('processBtn');
        const fileListDisplay = document.getElementById('fileListDisplay');

        let selectedFiles = [];

        // 1. æ–‡ä»¶é€‰æ‹©ç›‘å¬
        fileInput.addEventListener('change', (e) => {
            const rawFiles = Array.from(e.target.files);
            selectedFiles = rawFiles.filter(f => f.name.toLowerCase().endsWith('.glb'));

            if (selectedFiles.length === 0) {
                statusDiv.innerText = "âŒ æœªæ£€æµ‹åˆ° .glb æ–‡ä»¶";
                statusDiv.style.color = "red";
                processBtn.disabled = true;
                fileListDisplay.style.display = 'none';
                return;
            }

            statusDiv.innerText = `âœ… å·²å°±ç»ªï¼å…± ${selectedFiles.length} ä¸ªæ–‡ä»¶`;
            statusDiv.style.color = "green";
            processBtn.disabled = false;
            fileListDisplay.style.display = 'block';
            fileListDisplay.innerText = selectedFiles.map(f => f.name).join('\n');
        });

        window.processAllFiles = async function () {
            // Check browser support
            if (!window.showDirectoryPicker) {
                alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ–‡ä»¶å¤¹ç›´æ¥å†™å…¥ï¼Œè¯·ä½¿ç”¨ Chrome æˆ– Edgeã€‚");
                return;
            }

            let dirHandle;
            try {
                dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'downloads'
                });
            } catch (err) {
                statusDiv.innerText = "ğŸš« ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶å¤¹é€‰æ‹©";
                return;
            }

            // ================= ä¿®æ”¹å¼€å§‹ï¼šæ·»åŠ é˜²åˆ·æ–°ä¿æŠ¤ =================
            // å‘Šè¯‰æµè§ˆå™¨ï¼šå¦‚æœæœ‰äººï¼ˆåŒ…æ‹¬Live Serverï¼‰æƒ³åˆ·æ–°é¡µé¢ï¼Œå…ˆå¼¹çª—è¯¢é—®
            const preventRefresh = (e) => {
                e.preventDefault();
                e.returnValue = ''; // Chrome éœ€è¦è®¾ç½®è¿™ä¸ª
            };
            window.addEventListener('beforeunload', preventRefresh);
            // ================= ä¿®æ”¹ç»“æŸ =================

            processBtn.disabled = true;
            processBtn.innerText = "â³ æ­£åœ¨å†™å…¥æ–‡ä»¶å¤¹...";

            const config = {
                fixY: document.getElementById('fixY').checked,
                fixXZ: document.getElementById('fixXZ').checked
            };

            let successCount = 0;
            const total = selectedFiles.length;

            try { // æ·»åŠ ä¸€ä¸ªå¤§çš„ try-finally ç¡®ä¿æœ€åèƒ½è§£é™¤ä¿æŠ¤
                for (let i = 0; i < total; i++) {
                    const file = selectedFiles[i];
                    statusDiv.innerText = `âš™ï¸ æ­£åœ¨å¤„ç† (${i + 1}/${total}): ${file.name}`;

                    let fileUrl = null;
                    try {
                        fileUrl = URL.createObjectURL(file);
                        const gltf = await loadGlbFile(fileUrl);
                        fixModelGeometry(gltf.scene, config);

                        await saveToFolder(dirHandle, gltf.scene, file.name);

                        successCount++;
                        // æš‚åœä¸€ä¼šï¼Œé˜²æ­¢å†™å…¥è¿‡å¿«
                        // await new Promise(resolve => setTimeout(resolve, 500));

                    } catch (err) {
                        console.error(`å¤„ç† ${file.name} å¤±è´¥:`, err);
                        statusDiv.innerText += `\nâŒ ${file.name} å¤±è´¥: ${err.message}`;
                    } finally {
                        if (fileUrl) URL.revokeObjectURL(fileUrl);
                    }
                }

                statusDiv.innerText = `ğŸ‰ å…¨éƒ¨å®Œæˆï¼å·²å°† ${successCount} ä¸ªæ–‡ä»¶ä¿å­˜åˆ°é€‰å®šæ–‡ä»¶å¤¹ã€‚`;
                statusDiv.style.color = "#333";

            } finally {
                // ================= ä¿®æ”¹å¼€å§‹ï¼šè§£é™¤ä¿æŠ¤ =================
                // è¿è¡Œå®Œåï¼Œå…è®¸é¡µé¢æ­£å¸¸åˆ·æ–°æˆ–å…³é—­
                window.removeEventListener('beforeunload', preventRefresh);
                processBtn.innerText = "ğŸ’¾ é€‰æ‹©ä¿å­˜æ–‡ä»¶å¤¹å¹¶å¼€å§‹";
                processBtn.disabled = false;
                // ================= ä¿®æ”¹ç»“æŸ =================
            }
        };

        // --- è¾…åŠ©ï¼šåŠ è½½ GLB (ä¿®æ”¹ç‰ˆï¼šç§»é™¤å†…éƒ¨ URL é‡Šæ”¾) ---
        function loadGlbFile(url) {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();
                loader.load(
                    url,
                    (gltf) => {
                        resolve(gltf);
                    },
                    undefined,
                    (err) => reject(err)
                );
            });
        }

        // --- è¾…åŠ©ï¼šå‡ ä½•ä¿®æ­£ ---
        function fixModelGeometry(scene, config) {
            const box = new THREE.Box3().setFromObject(scene);
            const center = new THREE.Vector3();
            box.getCenter(center);

            const offsetX = config.fixXZ ? -center.x : 0;
            const offsetY = config.fixY ? -box.min.y : 0;
            const offsetZ = config.fixXZ ? -center.z : 0;

            if (offsetX === 0 && offsetY === 0 && offsetZ === 0) return;

            scene.traverse((node) => {
                if (node.isMesh) node.geometry.translate(offsetX, offsetY, offsetZ);
            });

            scene.position.set(0, 0, 0);
            scene.rotation.set(0, 0, 0);
            scene.scale.set(1, 1, 1);
            scene.updateMatrixWorld(true);
        }

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šä¿å­˜åˆ°æ–‡ä»¶å¤¹ ---
        async function saveToFolder(dirHandle, scene, filename) {
            return new Promise((resolve, reject) => {
                const exporter = new GLTFExporter();
                exporter.parse(
                    scene,
                    async function (result) {
                        try {
                            // 1. è·å–æ–‡ä»¶å¥æŸ„ (å¦‚æœå­˜åœ¨åˆ™è¦†ç›–ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»º)
                            const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                            // 2. åˆ›å»ºå¯å†™æµ
                            const writable = await fileHandle.createWritable();
                            // 3. å†™å…¥äºŒè¿›åˆ¶æ•°æ®
                            await writable.write(new Blob([result], { type: 'application/octet-stream' }));
                            // 4. å…³é—­æµ
                            await writable.close();
                            resolve();
                        } catch (err) {
                            reject(err);
                        }
                    },
                    function (error) { reject(error); },
                    { binary: true }
                );
            });
        }
    </script>
</body>

</html>
